
\section{Overall structure of \texttt{tspnng.py}}

The \texttt{tspnng.py} file at a high level divided into the following chunks, 
each of which is expanded upon in the coming sections. The \texttt{main.py} file used to run the \texttt{main()} function
from the command-line is more of a  scratchpad for testing the functions in this file, and later pointing the 
main to the appropriate test harnesses inside the \texttt{tspnng.py} file. Hence \texttt{main.py} will be developed 
independently of this document for convenience because it will be subject to continuous changes. .  

<<tspnng.py>>=

<<Header statements>>
<<Data Generation>>
<<Generic utility classes and functions>>
<<Functions for plotting and interacting>>
<<Functions for generating various graphs>>
<<Functions for testing various hypotheses>>

@


<<Header statements>>=
import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib import rc
rc('font',**{'family':'serif','serif':['Palatino']})
rc('text', usetex=True)

import scipy as sp
import numpy as np
import random
from colorama import Fore, Back, Style

from scipy.optimize import minimize
from sklearn.cluster import KMeans
import argparse, sys, time

@


\section{Data Generation}

Alongside TSPLIB we will principally be using synthetic data i.e.uniform and non-uniform point-sets generated inside the unit-square $[0,1] \times [0,1]$. 
Note that each point is represented as a numpy array of size 2. 

<<Data Generation>>=
<<Synthetic data>>
<<TSPLIB data>>
@

This chunk generates uniform and non-uniform point sets in $[0,1] \times [0,1]$. To generate non-uniform point-sets we basically 
take a small set of uniformly distributed random points in the square, place a small square centered around each such random point and then
generate the appropriate number of points uniformly inside each of those squares. \footnote{A similar technique was used in Jon Bentley's experimental TSP paper}

<<Synthetic data>>=
def uniform_points(numpts):
     return  sp.rand(numpts, 2).tolist()

def non_uniform_points(numpts):

    cluster_size = int(np.sqrt(numpts)) 
    numcenters   = cluster_size
    centers      = sp.rand(numcenters,2).tolist()
    scale, points = 4.0, []

    for c in centers:
        cx, cy = c[0], c[1]
        sq_size      = min(cx,1-cx,cy, 1-cy)

        loc_pts_x    = np.random.uniform(low  = cx-sq_size/scale, 
                                         high = cx+sq_size/scale, 
                                         size = (cluster_size,))
        loc_pts_y    = np.random.uniform(low = cy-sq_size/scale, 
                                         high = cy+sq_size/scale, 
                                         size = (cluster_size,))

        points.extend(zip(loc_pts_x, loc_pts_y))

    num_remaining_pts = numpts - cluster_size * numcenters
    remaining_pts = sp.rand(num_remaining_pts, 2).tolist()
    points.extend(remaining_pts)
    return points
@

This chunk principally just reads in TSPLIB data and massages it into a format appropriate for the current code. 

<<TSPLIB data>>=
@

YAML\cite{ben2009yaml} is a convenient serialization and data-interchange format that we will be using principally 
for serializing data onto disk. Python has particularly good libraries in dealing with YAML. Basically, 
YAML stores data similar to a Python dictionary. Infact the \texttt{yaml} module provides an function to 
transparently encode any (appropriate) Python dictionary into a YAML file. In the function below, the 
\texttt{data} argument is a dictionary, and \texttt{dir\_name} and \texttt{file\_name} are strings. 
 
<<Generic utility classes and functions>>=
def write_to_yaml_file(data, dir_name, file_name):
   import yaml
   with open(dir_name + '/' + file_name, 'w') as outfile:
          yaml.dump( data, outfile, default_flow_style = False)
@



The following set of code blocks create an interactive matplotlib canvas onto which the user can insert points, and then 
run the appropriate algorithm to visualize the intersection of the TSP and various graphs. 

Putting everything together, we set up the run handler by connecting the keyboard and mouse handlers
to the canvas. This is done in the main \verb|run_handler()| function. 

<<Functions for plotting and interacting>>=
def run_handler():
    fig, ax =  plt.subplots()
    run = TSPNNGInput()
    
    ax.set_xlim([xlim[0], xlim[1]])
    ax.set_ylim([ylim[0], ylim[1]])
    ax.set_aspect(1.0)
    ax.set_xticks([])
    ax.set_yticks([])
      
    mouseClick   = wrapperEnterRunPointsHandler(fig,ax, run)
    fig.canvas.mpl_connect('button_press_event' , mouseClick )
      
    keyPress     = wrapperkeyPressHandler(fig,ax, run)
    fig.canvas.mpl_connect('key_press_event', keyPress   )
    plt.show()
@



There are two principal callback functions \verb|wrapperEnterRunPointshandler| and \verb|wrapperkeypresshandler| used in the code above. 
These encode the interaction between the mouse and keyboard to the matplotlib canvas. 

First we define the call back function for mouse-clicks. Double-clicking the left mouse button (denoted as ``button 1'' in the matplotlib world)
inserts a small circle patch representing a point. 

<<Functions for plotting and interacting>>=
xlim, ylim = [0,1], [0,1]
def wrapperEnterRunPointsHandler(fig, ax, run):
    def _enterPointsHandler(event):
        if event.name      == 'button_press_event'     and \
           (event.button   == 1)                       and \
            event.dblclick == True                     and \ 
            event.xdata  != None                       and\ 
            event.ydata  != None:

             newPoint = (event.xdata, event.ydata)
             run.sites.append( newPoint  )
             patchSize  = (xlim[1]-xlim[0])/140.0
                   
             ax.add_patch( mpl.patches.Circle( newPoint, radius = patchSize,
                                               facecolor='blue', edgecolor='black'  ))
             ax.set_title('Points Inserted: ' + str(len(run.sites)), \
                           fontdict={'fontsize':40})
             applyAxCorrection(ax)
             fig.canvas.draw()

    return _enterPointsHandler
@

Now a call-back function for keyboard. Pressing \verb|`i'| or \verb|`I'| on the keyboard further prompts the 
user to insert a 2 or 3 letter code to indicate which graph should span the points. 

<<Functions for plotting and interacting>>=
def wrapperkeyPressHandler(fig,ax, run): 
       def _keyPressHandler(event):
               if event.key in ['i', 'I']:                     
                     <<Enter spanning graph>>    
               elif event.key in ['n', 'N', 'u', 'U']: 
                     <<Enter type of point set>>                   
               elif event.key in ['c', 'C']: 
                     <<Clear all states and the canvas>>
                   
       return _keyPressHandler
@

We now elaborate on the chunks in \verb|wrapperkeypresshandler|, and implement the boring technicalities. You 
can skip ahead to the next sections, at this point, if you wish. 

The user should type the code enclosed in the brackets (e.g. \verb|dt| for delaunay triangulation) to generate the 
indicated graph that spans the points. 

<<Enter spanning graph>>=
algo_str = raw_input(Fore.YELLOW                             +\
               "Enter code for the graph you need to span the points:\n"  +\
               "(dt)   Delaunay Triangulation           \n"  +\
               "(knng) k-Nearest Neighbor Graph           \n"  +\
               Style.RESET_ALL)
algo_str = algo_str.lstrip()

if algo_str == 'dt':
      geometric_graph = pass
      
elif algo_str == 'knng'
      k_str = raw_input(Fore.YELLOW + '--> What value of k do you want? ')
      k     = int(k_str)
      geometric_graph = pass

else:
      print("Unknown option! ")
      sys.exit()

clearAxPolygonPatches(ax)
applyAxCorrection(ax)

## --> Plot spanning graph onto ax
fig.canvas.draw()
@

If you want to enter a uniformly or non-uniformly distributed point-set in the unit-square press \verb|`u`| or \verb|`n`|
respectively after being prompted. 

<<Enter type of point set>>=
numpts = int(raw_input("\n" + Fore.YELLOW+\
                       "How many points should I generate?: "+\
                       Style.RESET_ALL)) 
run.clearAllStates()
ax.cla()
               
applyAxCorrection(ax)
ax.set_xticks([])
ax.set_yticks([])
fig.texts = []
                 
if event.key in ['n', 'N']: 
        run.sites = non_uniform_points(numpts)
else : 
        run.sites = uniform_points(numpts)

patchSize  = (xlim[1]-xlim[0])/140.0

for site in run.sites:      
    ax.add_patch(mpl.patches.Circle(site, radius = patchSize, \
                 facecolor='blue',edgecolor='black' ))

ax.set_title('Points : ' + str(len(run.sites)), fontdict={'fontsize':40})
fig.canvas.draw()

@

If you want to wipe the canvas and the data inside the run clean, then as indicated in the following code
chunk just press \verb|`c`|. 

<<Clear all states and the canvas>>=
run.clearAllStates()
ax.cla()
                                 
applyAxCorrection(ax)
ax.set_xticks([])
ax.set_yticks([])
                                    
fig.texts = []
fig.canvas.draw()
@





Often the \verb|ax| object has to be reset and cleaned of the various segment and circle patches, or even resetting the 
aspect ratio of the \verb|ax| object to be 1.0. These ``cleanup'' functions are implemented next. 

<<Functions for plotting and interacting >>=
def applyAxCorrection(ax):
      ax.set_xlim([xlim[0], xlim[1]])
      ax.set_ylim([ylim[0], ylim[1]])
      ax.set_aspect(1.0)

def clearPatches(ax):
    for index , patch in zip(range(len(ax.patches)), ax.patches):
        if isinstance(patch, mpl.patches.Polygon) == True:
            patch.remove()
    ax.lines[:]=[]
    applyAxCorrection(ax)

def clearAxPolygonPatches(ax):

    for index , patch in zip(range(len(ax.patches)), ax.patches):
        if isinstance(patch, mpl.patches.Polygon) == True:
            patch.remove()
    ax.lines[:]=[]
    applyAxCorrection(ax)
@


<<Functions for generating various graphs>>=
@
<<Functions for testing various hypotheses>>=
@

