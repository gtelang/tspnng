

\section{Overall structure of \texttt{tspnng.py}}

The \texttt{tspnng.py} file at a high level divided into the following chunks, 
each of which is expanded upon in the coming sections. The \texttt{main.py} file used to run the \texttt{main()} function
from the command-line is more of a  scratchpad for testing the functions in this file, and later pointing the 
main to the appropriate test harnesses inside the \texttt{tspnng.py} file. Hence \texttt{main.py} will be developed 
independently of this document for convenience because it will be subject to continuous changes. .  

<<tspnng.py>>=

<<Headers>>
<<Data Generation>>
<<Generic utility classes and functions>>
<<Functions for plotting and interacting>>
<<Functions for generating various graphs>>
<<Functions dealing with intersecting two geometric graphs>>
<<Testing hypotheses>>
@


<<Headers>>=
import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib import rc
rc('font',**{'family':'serif','serif':['Palatino']})
rc('text', usetex=True)

import scipy as sp
import numpy as np
import random
import networkx as nx

from sklearn.cluster import KMeans
import argparse, sys, time
from colorama import Fore, Style, Back
@


\section{Data Generation}

Alongside TSPLIB we will also be using synthetic data-sets i.e. uniform and non-uniform point-sets generated inside the unit-square $[0,1] \times [0,1]$. 
Note that each point is represented as a numpy array of size 2. 

<<Data Generation>>=
<<Synthetic data>>
<<TSPLIB data>>
@

This chunk generates uniform and non-uniform point sets in $[0,1] \times [0,1]$. To generate non-uniform point-sets we basically 
take a small set of uniformly distributed random points in the square, place a small square centered around each such random point and then
generate the appropriate number of points uniformly inside each of those squares. \footnote{A similar technique was used in Jon Bentley's experimental TSP paper}
The size of the square is proportional to the distance of the sampled point from the boundary of the unit square. Thus you will often see tight clusters
near the boundary as you increase the number of input points (\texttt{`numpts`}). This was done to make sure all points get generated in the unit square. 
This would make it convenient for the purposes of plotting. Other non-uniform point-generation schemes will later be considered depending on which 
direction our investigation proceeds. 


<<Synthetic data>>=
def uniform_points(numpts):
     return  sp.rand(numpts, 2).tolist()

def non_uniform_points(numpts):

    cluster_size = int(np.sqrt(numpts)) 
    numcenters   = cluster_size
    centers      = sp.rand(numcenters,2).tolist()
    scale, points = 4.0, []

    for c in centers:
        cx, cy = c[0], c[1]
        sq_size      = min(cx,1-cx,cy, 1-cy)

        loc_pts_x    = np.random.uniform(low  = cx-sq_size/scale, 
                                         high = cx+sq_size/scale, 
                                         size = (cluster_size,))
        loc_pts_y    = np.random.uniform(low = cy-sq_size/scale, 
                                         high = cy+sq_size/scale, 
                                         size = (cluster_size,))

        points.extend(zip(loc_pts_x, loc_pts_y))

    num_remaining_pts = numpts - cluster_size * numcenters
    remaining_pts = sp.rand(num_remaining_pts, 2).tolist()
    points.extend(remaining_pts)
    return points
@

This chunk principally just reads in TSPLIB data and massages it into a format appropriate for the current code. 

<<TSPLIB data>>=
@

\section{Data Storage}
YAML\cite{ben2009yaml} is a convenient serialization and data-interchange format that we will be using 
for serializing output data of different experiments onto disk. Python has particularly good libraries for dealing with YAML. Basically, 
YAML records data in a format similar to a Python dictionary. Infact the \texttt{yaml} module provides a function that
transparently encodes any (appropriate) Python dictionary into a YAML file. In the function below, the 
\texttt{data} argument is a dictionary, and \texttt{dir\_name} and \texttt{file\_name} are strings. 
 
<<Generic utility classes and functions>>=
def write_to_yaml_file(data, dir_name, file_name):
   import yaml
   with open(dir_name + '/' + file_name, 'w') as outfile:
          yaml.dump( data, outfile, default_flow_style = False)
@


\section{Setting up TSPNNGInput class}

The following class is used to keep track of the points inserted thus far, along with 
any other auxiliary information. It basically functions as a convenience wrapper class around 
the main input data (basically a bunch of points in $\RR^2$) and a wrapper function around 
various graph generators such as TSP, Delaunary, $k\text{-}$NNG etc. 

<<Generic utility classes and functions>>=
class TSPNNGInput:
      def __init__(self, points=[]):
          self.points            = points

      def clearAllStates (self):
          self.points = []

      def generate_geometric_graph(self,graph_code):
           pass
@

\section{Setting up the Interactive Canvas}
The following set of code blocks create an interactive matplotlib canvas onto which the user can insert points, and then 
run the appropriate algorithm to visualize the intersection of the TSP and various graphs. 

We first set up the run handler function (each ``run'' corresponds to a run of the code on a particular data-set generated synthetically)
by connecting the keyboard and mouse handlers to the canvas. 

<<Functions for plotting and interacting>>=
def run_handler():
    fig, ax =  plt.subplots()
    run = TSPNNGInput()
    
    ax.set_xlim([xlim[0], xlim[1]])
    ax.set_ylim([ylim[0], ylim[1]])
    ax.set_aspect(1.0)
    ax.set_xticks([])
    ax.set_yticks([])
      
    mouseClick   = wrapperEnterRunPointsHandler(fig,ax, run)
    fig.canvas.mpl_connect('button_press_event' , mouseClick )
      
    keyPress     = wrapperkeyPressHandler(fig,ax, run)
    fig.canvas.mpl_connect('key_press_event', keyPress   )
    plt.show()
@



There are two principal callback functions \verb|wrapperEnterRunPointshandler| and \verb|wrapperkeypresshandler| used in the code above. 
These encode the interaction between the mouse and keyboard to the matplotlib canvas. 

First we define the call back function for mouse-clicks. Double-clicking the left mouse button (denoted as ``button 1'' in the matplotlib world)
inserts a small circle patch representing a point. 

<<Functions for plotting and interacting>>=
xlim, ylim = [0,1], [0,1]
def wrapperEnterRunPointsHandler(fig, ax, run):
    def _enterPointsHandler(event):
        if event.name      == 'button_press_event'     and \
           (event.button   == 1)                       and \
            event.dblclick == True                     and \
            event.xdata  != None                       and \
            event.ydata  != None:

             newPoint = np.asarray([event.xdata, event.ydata])
             run.points.append( newPoint  )
             print("You inserted ", newPoint)

             patchSize  = (xlim[1]-xlim[0])/140.0
                   
             ax.add_patch( mpl.patches.Circle( newPoint, radius = patchSize,
                                               facecolor='blue', edgecolor='black'  ))
             ax.set_title('Points Inserted: ' + str(len(run.points)), \
                           fontdict={'fontsize':25})
             applyAxCorrection(ax)
             fig.canvas.draw()

    return _enterPointsHandler
@

Now a call-back function for keyboard. Pressing \verb|`i'| or \verb|`I'| on the keyboard further prompts the 
user to insert a 2 or 3 letter code to indicate which graph should span the points. 

<<Functions for plotting and interacting>>=
def wrapperkeyPressHandler(fig,ax, run): 
       def _keyPressHandler(event):
               if event.key in ['i', 'I']:                     
                     <<Enter spanning graph>>    
               elif event.key in ['n', 'N', 'u', 'U']: 
                     <<Enter type of point set>>                   
               elif event.key in ['c', 'C']: 
                     <<Clear all states and the canvas>>
                   
       return _keyPressHandler
@

We now elaborate on the chunks in \verb|wrapperkeypresshandler|, and implement the boring technicalities. You 
can skip ahead to the next sections, at this point, if you wish. 

The user should type the code enclosed in the brackets (e.g. `\verb|dt|' for delaunay triangulation) to generate the 
indicated graph that spans the points. 

<<Enter spanning graph>>=
algo_str = input(Fore.YELLOW + "Enter code for the graph you need to span the points:\n" + Style.RESET_ALL  +\
                     "(knng) k-Nearest Neighbor Graph        \n"            +\
                     "(mst)  Minimum Spanning Tree           \n"            +\
                     "(dt)   Delaunay Triangulation         \n"             +\
                     "(tsp)  TSP\n")
algo_str = algo_str.lstrip()

if algo_str == 'knng':
      k_str = input('===> What value of k do you want? ')
      k     = int(k_str)
      geometric_graph = get_knng_graph(run.points,k)

elif algo_str == 'mst':
     geometric_graph = get_mst_graph(run.points)

elif algo_str == 'dt':
      geometric_graph = get_delaunay_tri_graph(run.points)

elif algo_str == 'tsp':
     geometric_graph = get_tsp_graph(run.points)

else:
      print(Fore.YELLOW, "I did not recognize that option.", Style.RESET_ALL)
      geometric_graph = None

render_graph(geometric_graph,fig,ax)
fig.canvas.draw()
@

If you want to enter a uniformly or non-uniformly distributed point-set in the unit-square press \verb|`u`| or \verb|`n`|
respectively after being prompted. 

<<Enter type of point set>>=
numpts = int(input("\nHow many points should I generate?: ")) 
run.clearAllStates()
ax.cla()
applyAxCorrection(ax)

ax.set_xticks([])
ax.set_yticks([])
fig.texts = []
                 
if event.key in ['n', 'N']: 
        run.points = non_uniform_points(numpts)
else : 
        run.points = uniform_points(numpts)

patchSize  = (xlim[1]-xlim[0])/140.0

for site in run.points:      
    ax.add_patch(mpl.patches.Circle(site, radius = patchSize, \
                 facecolor='blue',edgecolor='black' ))

ax.set_title('Points : ' + str(len(run.points)), fontdict={'fontsize':40})
fig.canvas.draw()
@

If you want to wipe the canvas and the data inside the run clean, then as indicated in the following code
chunk just press \verb|`c`|. 

<<Clear all states and the canvas>>=
run.clearAllStates()
ax.cla()
                                 
applyAxCorrection(ax)
ax.set_xticks([])
ax.set_yticks([])
                                    
fig.texts = []
fig.canvas.draw()
@





Often the \verb|ax| object has to be reset and cleaned of the various segment and circle patches, or even resetting the 
aspect ratio of the \verb|ax| object to be 1.0. These ``cleanup'' functions that were called in some of the code blocks above 
are implemented next. 

<<Functions for plotting and interacting>>=
def applyAxCorrection(ax):
      ax.set_xlim([xlim[0], xlim[1]])
      ax.set_ylim([ylim[0], ylim[1]])
      ax.set_aspect(1.0)

def clearPatches(ax):
    for index , patch in zip(range(len(ax.patches)), ax.patches):
        if isinstance(patch, mpl.patches.Polygon) == True:
            patch.remove()
    ax.lines[:]=[]
    applyAxCorrection(ax)

def clearAxPolygonPatches(ax):

    for index , patch in zip(range(len(ax.patches)), ax.patches):
        if isinstance(patch, mpl.patches.Polygon) == True:
            patch.remove()
    ax.lines[:]=[]
    applyAxCorrection(ax)
@


\section{Generating various geometric graphs}

For manipulating abstract graphs we use the NetworkX \cite{hagberg2008exploring} \footnote{already available inside the Anaconda Python distribution by default}. 
This section deals with generating the various geometric graphs using packages like Scipy and Sklearn and then converting them into a NetworkX graph
with the necessary edge and node attributes. Note that all the nodes in the abstract constructed below have the same numbering across all grap have the same 
numbering across all graphs: namely, the order in which the points occur in the \verb|points| array argument. 


\subsection{$k\text{-}$NNG}
<<Functions for generating various graphs>>=

def get_knng_graph(points,k):
     points = np.array(points)

     ### --> Make the graph here
     knng_graph = None
     return knng_graph
@



\subsection{Minimum Spanning Tree}

<<Functions for generating various graphs>>=

def get_mst_graph(points):
     points = np.array(points)

     ### --> Make the graph here
     mst_graph = None
     return mst_graph

@





\subsection{Delaunay Triangulation}

Using the example code on \href{https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Delaunay.html}{Scipy docs} here. 
After obtaining the list of edges we convert it into a NetworkX graph with any important edge and vertex attributes. 

<<Functions for generating various graphs>>=
def get_delaunay_tri_graph(points):
     points = np.array(points)
     tri    = sp.spatial.Delaunay(points)

     ### --> Make the graph here
     deltri_graph = None
     return deltri_graph
@


\subsection{TSP tour}
<<Functions for generating various graphs>>=
def get_tsp_graph(points):

     import tsp
     points = np.array(points)
     coords = [{"coords":pt} for pt in points]
     t      = tsp.tsp(points)
     idxs_along_tsp = t[1]


     tsp_graph = nx.Graph()
     tsp_graph.add_nodes_from(zip(range(len(points)), coords))

     edge_list = zip(idxs_along_tsp, idxs_along_tsp[1:]) + [(idxs_along_tsp[-1],idxs_along_tsp[0])]
     tsp_graph.add_edges_from(  edge_list  )

     print(Fore.RED, list_edges(tsp_graph), Style.RESET_ALL)

     return tsp_graph
@



\section{Rendering the graphs}


<<Functions for plotting and interacting>>=
def render_graph(geometric_graph,fig,ax):
     if geometric_graph is None:
            return

     t = np.arange(0.0, 2.0, 0.01)
     s = 1 + np.sin(2 * np.pi * t)
     ax.plot(t, s)
     fig.canvas.draw()
@


\section{Finding common edges between two graphs}

To find the set of edges common to two graphs on the same set of nodes, we take take 
an edge from the smaller of the two graphs (i.e. the one with the smaller number of edges) and check 
whether it exists in the other. Repeat. 

 

<<Functions dealing with intersecting two geometric graphs>>=

@

\section{Hypothesis testing!}

<<Testing hypotheses>>=
@